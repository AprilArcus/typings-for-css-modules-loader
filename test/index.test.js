// @ts-check
/// <reference types="jest" />
const webpack = require("webpack");
const path = require("path");
const memoryfs = require("memory-fs");

beforeEach(() => {
  jest.mock("../src/persist");
});

it("default options", async () => {
  await runTest();

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("with sourcemap", async () => {
  await runTest({
    cssLoaderOptions: {
      sourceMap: true
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("no modules", async () => {
  await runTest({
    cssLoaderOptions: {
      modules: false
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(0);
});

it("localsConvention asIs", async () => {
  await runTest({
    cssLoaderOptions: {
      localsConvention: "asIs"
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("localsConvention camelCase", async () => {
  await runTest({
    cssLoaderOptions: {
      localsConvention: "camelCase"
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("with prettier", async () => {
  await runTest({
    options: {
      formatter: "prettier"
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("with no formatter", async () => {
  await runTest({
    options: {
      formatter: "none"
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

it("with banner", async () => {
  await runTest({
    options: {
      banner: "// autogenerated by typings-for-css-modules-loader"
    }
  });

  const persisteMock = jest.requireMock("../src/persist");
  expect(persisteMock).toBeCalledTimes(1);
  expect(persisteMock.mock.calls[0][1]).toMatchSnapshot();
});

async function runTest({ options = {}, cssLoaderOptions = {} } = {}) {
  const compiler = webpack({
    entry: path.resolve(__dirname, "./example.css"),
    target: "node",
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            {
              loader: require.resolve("../src/index.js"),
              options
            },
            {
              loader: "css-loader",
              options: Object.assign(
                {
                  modules: true
                },
                cssLoaderOptions
              )
            }
          ]
        }
      ]
    },
    mode: "none"
  });

  compiler.outputFileSystem = new memoryfs();

  /** @type {webpack.Stats} */
  const stats = await new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      if (err) {
        reject(err);
      } else {
        resolve(stats);
      }
    });
  });

  const s = stats.toJson();
  expect(s.errors).toHaveLength(0);
}
